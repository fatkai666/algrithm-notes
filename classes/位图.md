# 位图

设计一种集合的数据结构，用于验证某个数字是否存在于这个集合里
优势：用bit组成的数组存放值，bit的0/1状态来表示该数字是否存在，取值和存值操作都通过位运算完成，极大的节省空间
限制：范围连续且不能过大

```javascript
class BitSet {
    /**
     * 构造函数，初始化位图
     * @param {number} n - 支持的最大数字（范围为0~n-1）
     */
    constructor(n) {
        this.size = n;
        this.set = new Array(Math.floor((n + 31) / 32)).fill(0);
        // 返回代理对象，自动拦截方法调用做越界检查
        return new Proxy(this, {
            get(target, prop, receiver) {
                const methodNames = ['add', 'remove', 'reverse', 'contains'];
                if (methodNames.includes(prop)) {
                    return function(num, ...args) {
                        if (num < 0 || num >= target.size) {
                            throw new RangeError(`数字 ${num} 超出范围 0~${target.size - 1}`);
                        }
                        return target[prop].call(target, num, ...args);
                    };
                }
                return Reflect.get(target, prop, receiver);
            }
        });
    }

    /**
     * 添加数字到集合
     * @param {number} num - 要添加的数字
     */
    add(num) {
        this.set[Math.floor(num / 32)] |= 1 << (num % 32);
    }

    /**
     * 从集合中移除数字
     * @param {number} num - 要移除的数字
     */
    remove(num) {
        this.set[Math.floor(num / 32)] &= ~(1 << (num % 32));
    }

    /**
     * 翻转某个数字的存在状态
     * @param {number} num - 要翻转的数字
     */
    reverse(num) {
        this.set[Math.floor(num / 32)] ^= 1 << (num % 32);
    }

    /**
     * 判断数字是否存在于集合中
     * @param {number} num - 要判断的数字
     * @returns {boolean} - 存在返回true，否则false
     */
    contains(num) {
        return ((this.set[Math.floor(num / 32)] >> (num % 32)) & 1) === 1;
    }
}

```


```typescript
function checkBounds(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function(num: number, ...args: any[]) {
        if (num < 0 || num >= this.size) {
            throw new RangeError(`数字 ${num} 超出范围 0~${this.size - 1}`);
        }
        return originalMethod.apply(this, [num, ...args]);
    };
    return descriptor;
}

class BitSet {
    private set: number[];
    private size: number;

    /**
     * 构造函数，初始化位图
     * @param n 支持的最大数字（范围为0~n-1）
     */
    constructor(n: number) {
        this.size = n;
        this.set = new Array(Math.floor((n + 31) / 32)).fill(0);
    }

    /**
     * 添加数字到集合
     * @param num 要添加的数字
     */
    @checkBounds
    add(num: number): void {
        this.set[Math.floor(num / 32)] |= 1 << (num % 32);
    }

    /**
     * 从集合中移除数字
     * @param num 要移除的数字
     */
    @checkBounds
    remove(num: number): void {
        this.set[Math.floor(num / 32)] &= ~(1 << (num % 32));
    }

    /**
     * 翻转某个数字的存在状态
     * @param num 要翻转的数字
     */
    @checkBounds
    reverse(num: number): void {
        this.set[Math.floor(num / 32)] ^= 1 << (num % 32);
    }

    /**
     * 判断数字是否存在于集合中
     * @param num 要判断的数字
     * @returns 存在返回true，否则false
     */
    @checkBounds
    contains(num: number): boolean {
        return ((this.set[Math.floor(num / 32)] >> (num % 32)) & 1) === 1;
    }
}
```

```python
def check_bounds(func):
    def wrapper(self, num, *args, **kwargs):
        if num < 0 or num >= self.size:
            raise IndexError(f"数字 {num} 超出范围 0~{self.size - 1}")
        return func(self, num, *args, **kwargs)
    return wrapper

class BitSet:
    def __init__(self, n: int):
        """
        构造函数，初始化位图
        :param n: 支持的最大数字（范围为0~n-1）
        """
        self.size = n
        self.set = [0] * ((n + 31) // 32)

    @check_bounds
    def add(self, num: int) -> None:
        self.set[num // 32] |= 1 << (num % 32)

    @check_bounds
    def remove(self, num: int) -> None:
        self.set[num // 32] &= ~(1 << (num % 32))

    @check_bounds
    def reverse(self, num: int) -> None:
        self.set[num // 32] ^= 1 << (num % 32)

    @check_bounds
    def contains(self, num: int) -> bool:
        return ((self.set[num // 32] >> (num % 32)) & 1) == 1
```

[设计位集](https://leetcode.cn/problems/design-bitset/)